<!--
 * This file is part of OverPy (https://github.com/Zezombye/overpy).
 * Copyright (c) 2019 Zezombye.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
-->
<!--stfu firefox -->
<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <link rel="icon" type="image/png" href="VS Code Extension/img/overpy.ico" />
        <title>OverPy Demo</title>

        <style>
            textarea {
                resize: vertical;
                -moz-tab-size: 4;
                -o-tab-size: 4;
                tab-size: 4;
            }

            body,
            textarea {
                color: #cccccc;
                background-color: #222222;
                scrollbar-color: #cccccc #222222;
            }

            a {
                color: lightblue;
            }

            .cm-editor {
                width: 100%;
                text-align: left;
                border: 2px solid gray;
                color: #cccccc;
                height: 320px;
            }

            .cm-content {
                white-space: pre-wrap !important;
                word-break: break-word !important;
                max-width: calc(100% - 32px);
            }

            .cm-cursor {
                border-color: #cccccc !important;
            }

            .cm-selectionBackground,
            ::selection {
                background-color: rgb(51, 153, 255) !important;
            }
        </style>
    </head>
    <body>
        <center>
            <a href="https://github.com/Zezombye/overpy"><h1>OverPy v8 language demo by Zezombye</h1></a>
            <p>
                <a href="https://github.com/Zezombye/overpy/blob/master/FUNCTIONS.md">Function documentation</a> | <button onclick="demoAddText();">Add example text</button> | Language:
                <select id="languageInput">
                    <option value="en-US">English [en-US]</option>
                    <option value="de-DE">Deutsch [de-DE]</option>
                    <option value="es-ES">Español (EU) [es-ES]</option>
                    <option value="es-MX">Español (AL) [es-MX]</option>
                    <option value="fr-FR">Français [fr-FR]</option>
                    <option value="it-IT">Italiano [it-IT]</option>
                    <option value="ja-JP">日本語 [ja-JP]</option>
                    <option value="ko-KR">한국어 [ko-KR]</option>
                    <option value="pl-PL">Polski [pl-PL]</option>
                    <option value="pt-BR">Português [pt-BR]</option>
                    <option value="ru-RU">Русский [ru-RU]</option>
                    <option value="zh-CN">简体中文 [zh-CN]</option>
                    <option value="zh-TW">繁體中文 [zh-TW]</option>
                </select>
            </p>

            <div id="workshop-text" style="float: left; width: 33%">
                <p>Workshop text</p>
                <button onclick="demoDecompile()">Decompile</button>
                <textarea id="workshop-textarea" onkeyup="getTextareaLineNumber(this, 'workshop');" onmouseup="this.onkeyup();" rows="20" style="width: 100%" wrap="off" placeholder="Note: the decompiler only supports code copied directly from Overwatch.&#10;&#10;If you wish to decompile code generated by a third-party tool (including OverPy),&#10;paste it into Overwatch and copy it."></textarea>
                <p style="float: left">line <span id="workshop-textarea-line-number"></span>, col <span id="workshop-textarea-col-number"></span></p>
            </div>

            <div id="overpy-text" style="float: left; width: 33%">
                <p>OverPy text</p>
                <button onclick="demoCompile()">Compile</button>
                <div id="cm-overpy-text"></div>
                <!--<textarea id="overpy-textarea" onkeyup="getTextareaLineNumber(this, 'overpy');" onmouseup="this.onkeyup();" rows="20" style="width:100%;" wrap="off"></textarea>
		<p style="float:left;">line <span id="overpy-textarea-line-number"></span>, col <span id="overpy-textarea-col-number"></span></p>-->
            </div>

            <div id="compiled-text" style="float: right; width: 34%">
                <p>Compiled text</p>
                <button style="visibility: hidden">hidden</button>
                <textarea id="compiled-textarea" onkeyup="getTextareaLineNumber(this, 'compiled');" onmouseup="this.onkeyup();" rows="20" style="width: 100%" wrap="off"></textarea>
                <p style="float: left">line <span id="compiled-textarea-line-number"></span>, col <span id="compiled-textarea-col-number"></span></p>
            </div>
        </center>

        <script src="out/overpy_standalone.js"></script>

        <script>
            const decompileTest = `/*
A gamemode I made for the Elo Hell jam.
Theme was "crunch time"
Time was 2h so the code is horrendous, lul
*/

globalvar timer
globalvar challenge
globalvar nbPlayersKilled
globalvar additionalTime
globalvar timeTarget

subroutine countdownTimer
subroutine nextChallenge

rule "timer":
    #debug(timer)
    #debug("Position: {}".format(hostPlayer.getPosition()))
    #debug("Facing direction: {}".format(hostPlayer.getFacingDirection()))
    hudHeader(getAllPlayers(), timer, HudPosition.TOP, 0, Color.WHITE, HudReeval.VISIBILITY_SORT_ORDER_AND_STRING, SpecVisibility.ALWAYS)
    timer = 5

rule "reset time":
    @Condition hostPlayer.isHoldingButton(Button.INTERACT)
    timer = 0

rule "player got kill":
    @Event playerEarnedElimination
    @Condition attacker == hostPlayer

    nbPlayersKilled++

def countdownTimer():
    @Name "countdown timer"

    hostPlayer.setStatusEffect(null, Status.ROOTED, 9999)
    hostPlayer.setAbility1Enabled(false)
    hostPlayer.setAbility2Enabled(false)
    if hostPlayer.getCurrentHero() == Hero.WIDOWMAKER:
        hostPlayer.setUltEnabled(true)
        wait()
        hostPlayer.setUltCharge(100)
    else:
        hostPlayer.setUltEnabled(false)
    hostPlayer.setPrimaryFireEnabled(false)
    hostPlayer.setSecondaryFireEnabled(false)
    timeTarget = timer+additionalTime
    chase(timer, timeTarget, duration=2, ChaseReeval.NONE)
    smallMessage(getAllPlayers(), 3)
    wait(1)
    smallMessage(getAllPlayers(), 2)
    wait(1)
    smallMessage(getAllPlayers(), 1)
    wait(1)
    stopChasingVariable(timer)
    chase(timer, 0, rate=1, ChaseReeval.NONE)
    smallMessage(getAllPlayers(), "Go!")
    hostPlayer.clearStatusEffect(Status.ROOTED)

def nextChallenge():
    @Name "challenge finished"
    destroyAllEffects()
    destroyAllDummies()
    stopChasingVariable(timer)
    nbPlayersKilled = 0
    challenge++

rule "player spawned in":
    @Condition hostPlayer.hasSpawned()
    wait(1)
    challenge = 1
    setObjectiveDescription(getAllPlayers(), "Challenge {}".format(challenge), HudReeval.VISIBILITY_SORT_ORDER_AND_STRING)

    #reset challenge vars
    nbPlayersKilled = 0

#10 seconds - possible in 5 though
rule "challenge 1":
    @Condition challenge == 1
    hostPlayer.teleport(vect(116.11, -1.22, -21))
    hostPlayer.setFacing(vect(1, 0, 0), Relativity.TO_WORLD)
    bigMessage(hostPlayer, "Get to the vortex!")
    additionalTime = 5
    hostPlayer.startForcingHero(Hero.LUCIO)
    createEffect(getAllPlayers(), Effect.BAD_AURA, Color.GREEN, vect(144, 9, -21), 2, EffectReeval.VISIBILITY_POSITION_AND_RADIUS)
    countdownTimer()
    hostPlayer.setAbility1Enabled(true)
    hostPlayer.setAbility2Enabled(true)

rule "challenge 1 finished":
    @Condition challenge == 1 and distance(hostPlayer.getPosition(), vect(144, 9, -21)) < 2
    nextChallenge()

#10 seconds - actually takes like 12
rule "challenge 2":
    @Condition challenge == 2
    hostPlayer.teleport(vect(96.45, -1.41, -21))
    hostPlayer.setFacing(vect(-1, 0, 0), Relativity.TO_WORLD)
    bigMessage(hostPlayer, "Hook em all!")
    hostPlayer.startForcingHero(Hero.ROADHOG)
    additionalTime = 10
    createDummy(Hero.REINHARDT, Team.1, -1, vect(81.96, -1.32, -23.80), vect(1, 0, 0))
    createDummy(Hero.REINHARDT, Team.1, -1, vect(81.96, -1.32, -21.06), vect(1, 0, 0))
    createDummy(Hero.REINHARDT, Team.1, -1, vect(81.96, -1.32, -18.34), vect(1, 0, 0))
    createDummy(Hero.ZARYA, Team.1, -1, vect(80.05, -1.40, -19.82), vect(1, 0, 0))
    createDummy(Hero.ZARYA, Team.1, -1, vect(80.05, -1.40, -22.72), vect(1, 0, 0))
    createDummy(Hero.ZARYA, Team.1, -1, vect(84.73, -1.36, -21), vect(1, 0, 0))
    countdownTimer()
    hostPlayer.setAbility1Enabled(true)

rule "challenge 2 dummies - rein":
    @Event eachPlayer
    @Team 1
    @Hero reinhardt
    @Condition challenge == 2

    do:
        eventPlayer.startForcingButton(Button.SECONDARY_FIRE)
        wait(2)
        eventPlayer.stopForcingButton(Button.SECONDARY_FIRE)
        wait(2)
    while RULE_CONDITION

rule "challenge 2 dummies - zarya":
    @Event eachPlayer
    @Team 1
    @Hero zarya
    @Condition challenge == 2
    do:
        wait(2)
        eventPlayer.forceButtonPress(Button.ABILITY_1)
        wait(2)
    while RULE_CONDITION

rule "challenge 2 finished":
    @Condition challenge == 2 and nbPlayersKilled == 6
    nextChallenge()

rule "challenge 3":
    @Condition challenge == 3

    hostPlayer.teleport(vect(20.51, 1.61, -68.87))
    hostPlayer.setFacing(vect(-1, 0, 0), Relativity.TO_WORLD)
    bigMessage(hostPlayer, "Kill em all (hold rclick)!")
    hostPlayer.startForcingHero(Hero.MCCREE)
    additionalTime = 10
    countdownTimer()
    hostPlayer.setSecondaryFireEnabled(true)
    hostPlayer.setPrimaryFireEnabled(true)
    hostPlayer.setAbility1Enabled(true)
    hostPlayer.setAbility2Enabled(true)
    createDummy(Hero.HAMMOND, Team.1, -1, vect(2.12, 5.74, -69.48), vect(0,0,0))
    createDummy(Hero.HAMMOND, Team.1, -1, vect(2.12, 5.74, -72.61), vect(0,0,0))
    createDummy(Hero.HAMMOND, Team.1, -1, vect(2.12, 5.74, -54.41), vect(0,0,0))
    createDummy(Hero.HAMMOND, Team.1, -1, vect(14, -1.25, -53), vect(0,0,0))
    createDummy(Hero.HAMMOND, Team.1, -1, vect(31.37, -0.25, -58.23), vect(0,0,0))
    createDummy(Hero.HAMMOND, Team.1, -1, vect(33.97, 6.75, -66.66), vect(0,0,0))


rule "challenge 3 stun":
    @Condition challenge == 3 and hostPlayer.getCurrentHero() == Hero.MCCREE

    do:
        hostPlayer.setStatusEffect(null, Status.KNOCKED_DOWN, 0.016)
        wait()
    while RULE_CONDITION


rule "challenge 3 finished":
    @Condition challenge == 3 and nbPlayersKilled == 6
    nextChallenge()

rule "challenge 4":
    @Condition challenge == 4
    hostPlayer.teleport(vect(-20, -1, -47.46))
    hostPlayer.setFacing(vect(0,0,-1), Relativity.TO_WORLD)
    bigMessage(hostPlayer, "Headshot Mondatta!")
    hostPlayer.startForcingHero(Hero.WIDOWMAKER)
    additionalTime = 10
    countdownTimer()
    hostPlayer.setAbility1Enabled(true)
    hostPlayer.setPrimaryFireEnabled(true)
    hostPlayer.setSecondaryFireEnabled(true)
    createDummy(Hero.ZENYATTA, Team.1, -1, vect(-57, 2.8, -131.51), vect(0,0,1))
    createDummy(Hero.REINHARDT, Team.1, -1, vect(-57.05, 2.80, -128.62), vect(0,0,1))
    createDummy(Hero.REINHARDT, Team.1, -1, vect(-59.12, 2.8, -131.50), vect(-1,0,0))
    createDummy(Hero.REINHARDT, Team.1, -1, vect(-57, 2.80, -134.54), vect(0,0,-1))
    createDummy(Hero.REINHARDT, Team.1, -1, vect(-55.11, 2.80, -131.51), vect(1,0,0))


rule "challenge 4 reins":
    @Event eachPlayer
    @Team 1
    @Hero reinhardt
    @Condition challenge == 4
    eventPlayer.startForcingButton(Button.SECONDARY_FIRE)

rule "challenge 4 end":
    @Condition challenge == 4 and nbPlayersKilled == 1
    declareTeamVictory(Team.2)

rule "lost":
    @Condition timer == 0
    declareTeamVictory(Team.1)
`

        </script>

        <script src="codemirror.min.js"></script>
        <script src="codemirror-persist-document-extension.js"></script>

        <script>
            const { basicSetup } = CM["codemirror"];
            const { EditorView, keymap } = CM["@codemirror/view"];
            const { indentWithTab, defaultKeymap, history, historyKeymap } = CM["@codemirror/commands"];
            const { LRLanguage, LanguageSupport, StreamLanguage, HighlightStyle, syntaxHighlighting, indentUnit, foldNodeProp, foldInside, indentNodeProp } = CM["@codemirror/language"];
            const { styleTags, tags } = CM["@lezer/highlight"];
            const { LRParser } = CM["@lezer/lr"];
            const { persistDocument } = CM["@overpy/codemirror-persist-document"];

            function getIndentForLine(state, line) {
                const spaces = /^\s*/.exec(state.doc.lineAt(line).text)?.[0].length;
                const tabs = /^\t*/.exec(state.doc.lineAt(line).text)?.[0].length;
                return Math.floor(spaces / 4) + tabs;
            }

            function autoIndentOnEnter({ state, dispatch }) {
                const changes = state.changeByRange((range) => {
                    const { from, to } = range,
                        line = state.doc.lineAt(from);

                    const indent = getIndentForLine(state, from);
                    let insert = "\n";
                    for (let i = 0; i < indent; i++) {
                        insert += "    ";
                    }

                    const openBracket = /[\{\(\[]/gm.exec(state.doc.lineAt(from).text)?.[0].length;
                    const closeBracket = /[\}\)\]]/gm.exec(state.doc.lineAt(from).text)?.[0].length;
                    if (openBracket && !closeBracket) insert += "    ";

                    return { changes: { from, to, insert }, range: EditorSelection.cursor(from + insert.length) };
                });

                dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
                return true;
            }

            const overpyHighlight = HighlightStyle.define([
                { tag: tags.keyword, color: "#C586C0" },
                { tag: tags.operator, color: "#569cd6" },
                { tag: tags.variableName, color: "#9CDCFE" },
                { tag: tags.string, color: "#ce9178" },
                { tag: tags.escape, color: "#d7ba7d" },
                { tag: tags.annotation, color: "#d16969" },
                { tag: tags.attributeValue, color: "#6796e6" },
                { tag: tags.number, color: "#b5cea8" },
                { tag: tags.labelName, color: "#4EC9B0" },
                { tag: tags.comment, color: "#6A9955" },
                { tag: tags.macroName, color: "#569cd6" },
                { tag: tags.invalid, color: "#f44747" },
                { tag: tags.propertyName, color: "#4FC1FF" },
                { tag: tags.processingInstruction, color: "#DCDCAA" },
                { tag: tags.className, color: "#d7ba7d" },
                { tag: tags.modifier, color: "#9CDCFE" },
            ]);

            const overpyLanguage = {
                startState: function () {
                    return {
                        isInLineComment: false,
                        isInMultilineComment: false,
                        stringChar: null,
                        isInMacro: false,
                        isInAnnotation: false,
                        isInGoto: false,
                    };
                },
                token: function (stream, state) {
                    if (stream.eatSpace()) {
                        return null;
                    }
                    if (stream.eol()) {
                        return null;
                    }
                    //console.log("current: |"+stream.peek()+"|, string char: |"+state.stringChar+"|");
                    if (state.stringChar) {
                        if (stream.match(/\\([\\"'nrtzbf]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|&\w+;)/)) {
                            return "escape";
                        }
                        if (stream.peek() === state.stringChar) {
                            state.stringChar = null;
                        }
                        stream.next();
                        return "string";
                    }
                    if (state.isInAnnotation) {
                        state.isInAnnotation = false;
                        stream.skipToEnd();
                        return "attributeValue";
                    }
                    if (state.isInGoto) {
                        state.isInGoto = false;
                        stream.skipToEnd();
                        return "labelName";
                    }
                    if (state.isInLineComment) {
                        if (!stream.match(/.*\\ *$/)) {
                            state.isInLineComment = false;
                        }
                        stream.skipToEnd();
                        return "comment";
                    }
                    if (state.isInMultilineComment) {
                        if (stream.match("*/")) {
                            state.isInMultilineComment = false;
                        } else {
                            stream.next();
                        }
                        return "comment";
                    }
                    if (state.isInMacro) {
                        if (!stream.match(/.*\\ *$/)) {
                            state.isInMacro = false;
                        }
                        stream.skipToEnd();
                        return "macroName";
                    }
                    if (stream.match(/(goto)\b/)) {
                        state.isInGoto = true;
                        return "keyword";
                    }
                    if (stream.match(/\b[a-z]+(?=["'])/)) {
                        return "modifier";
                    }
                    if (stream.match(/(if|else|elif|do|while|for|return|continue|false|true|null|lambda|pass|del|break|switch|case|default|def|rule|settings|globalvar|playervar|subroutine|unsigned|signed|int|float|bool|enum)\b/)) {
                        return "keyword";
                    }
                    if (stream.match(/(False|True|None|Null|class|finally|is|try|from|nonlocal|with|as|yield|assert|except|raise|disabled|import)\b/)) {
                        return "invalid";
                    }
                    if (stream.match("/*")) {
                        state.isInMultilineComment = true;
                        return "comment";
                    }
                    if (stream.match(/(and|or|not|in)\b|((\+|\-|\*\*|\/|\%|\*|<|>)=?)|(\=)|\.|((min|max|\!)\=)/)) {
                        return "operator";
                    }
                    if (stream.match(/(eventPlayer|attacker|victim|eventDamage|eventHealing|eventWasCriticalHit|eventWasEnvironment|eventWasHealthPack|eventAbility|eventDirection|healee|healer|hostPlayer|localPlayer|loc|RULE_CONDITION|RULE_START|__\w+__|[A-Z]|[A-D][A-Z])\b/)) {
                        return "variable";
                    }
                    if (stream.match(/[A-Z_\d]+\b/)) {
                        return "propertyName";
                    }
                    if (stream.match(/\b\w+(?=\()/)) {
                        return "processingInstruction";
                    }
                    if (stream.match(/\b[A-Z][a-z_]\w*\b/)) {
                        return "className";
                    }
                    if (stream.match(/@(Event|Hero|Team|Slot|SuppressWarnings)+\b/)) {
                        state.isInAnnotation = true;
                        return "annotation";
                    }
                    if (stream.match(/@\w+\b/)) {
                        return "annotation";
                    }
                    if (stream.match(/\b[+-]?(\d*\.)?\d+\b/)) {
                        return "number";
                    }
                    if (stream.match(/[A-Za-z\d_]+(?=:)/)) {
                        return "labelName";
                    }
                    if (stream.match(/\w+/)) {
                        return null;
                    }
                    if (stream.match("#!")) {
                        state.isInMacro = true;
                        return "macroName";
                    }
                    if (stream.match("#")) {
                        state.isInLineComment = true;
                        return "comment";
                    }
                    var char = stream.next().toString();
                    //console.log(char);
                    if (char === "'" || char === '"') {
                        state.stringChar = char;
                        return "string";
                    }
                    return null;
                },
            };

            var overpyTextEditorView = new EditorView({
                extensions: [syntaxHighlighting(overpyHighlight), StreamLanguage.define(overpyLanguage), history(), indentUnit.of("    "), keymap.of([indentWithTab, ...defaultKeymap, ...historyKeymap, { key: "Enter", run: autoIndentOnEnter }]), basicSetup, persistDocument("opyTextEditorDoc")],
                parent: document.getElementById("cm-overpy-text"),
            });
        </script>

        <script>
            function getTextareaLineNumber(textarea, name) {
                document.getElementById(name + "-textarea-line-number").innerHTML = textarea.value.substr(0, textarea.selectionStart).split("\n").length;
                document.getElementById(name + "-textarea-col-number").innerHTML = textarea.selectionStart - textarea.value.substr(0, textarea.selectionStart).lastIndexOf("\n");
            }

            function demoDecompile() {
                var str = " ";
                var language = document.getElementById("languageInput").value;

                try {
                    str = decompileAllRules(document.getElementById("workshop-textarea").value, language);
                } catch (e) {
                    console.log(e);
                    str = "" + e + ", contact CactusPuppy about this";
                }
                //document.getElementById("overpy-textarea").value = str;
                overpyTextEditorView.dispatch({
                    changes: { from: 0, to: overpyTextEditorView.state.doc.length, insert: str },
                });
            }

            async function demoCompile() {
                var str = "";
                var language = document.getElementById("languageInput").value;
                try {
                    compilationResult = await compile(overpyTextEditorView.state.doc.toString(), language);
                    console.log(compilationResult);
                    str += "//Elements: " + compilationResult.nbElements + "\n";
                    if (compilationResult.activatedExtensions.length > 0) {
                        str += "//Extension points: " + compilationResult.spentExtensionPoints + "/" + (compilationResult.availableExtensionPoints < 0 ? "unknown" : compilationResult.availableExtensionPoints) + "\n";
                    }
                    str += compilationResult.result;
                    if (compilationResult.encounteredWarnings.length > 0) {
                        var strWarn = "/* Warnings were encountered:\n\n";
                        for (var warning of compilationResult.encounteredWarnings) {
                            strWarn += " - " + warning + "\n\n";
                        }
                        strWarn += "*/\n";
                        str = strWarn + str;
                    }
                } catch (e) {
                    console.log(e);
                    str = e;
                }
                document.getElementById("compiled-textarea").value = str;
            }

            function demoAddText() {

                overpyTextEditorView.dispatch({
                    changes: { from: 0, to: overpyTextEditorView.state.doc.length, insert: decompileTest },
                });
                document.getElementById("workshop-textarea").value = "";
                document.getElementById("compiled-textarea").value = "";
            }
        </script>
    </body>
</html>
